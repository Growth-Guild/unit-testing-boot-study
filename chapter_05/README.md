# Chapter 05. 목과 테스트 취약성
- - -

* 분파 간 의견 차이는 테스트 격리 문제에 대한 견해에서 비롯된다.
* 런던파는 테스트 대상 코드 조각을 서로 분리하고 불변 의존성을 제외한 모든 의존성에 테스트 대역을 써서 격리하고자 한다.
* 고전파는 단위 테스트를 분리해서 병렬로 실행할 수 있게 하고자 한다. 테스트 간에 공유하는 의존성에 대해서만 테스트 대역을 사용한다.

### 테스트 대역 유형
* 테스트 대역은 모든 유형의 비운영용 가짜 의존성을 설명하는 포괄적인 용어다.
* 테스트 대역의 주 용도는 테스트를 편리하게 하는 것이다.
* 테스트 대역에는 더미, 스텁, 스파이, 목, 페이크라는 다섯 가지가 있지만, 실제로는 목과 스텁의 두가지 유형으로 나눌 수 있다.
  * 목 (목, 스파이)
  * 스텁 (스텁, 더미, 페이크)
* 목과 스텁의 차이점
  * 목은 외부로 나가는 상호 작용을 모방하고 검사하는 데 도움이 된다. 이러한 상호작용은 SUT가 상태를 변경하기 위한 의존성을 호출하는 것에 해당한다.
  * 스텁은 내부로 들어오는 상호 작용을 모방하는 데 도움이 된다. 이러한 상호 작용은 SUT가 입력 데이터를 얻기 위한 의존성을 호출하는 것에 해당한다.

### 목과 스파이
* 목과 스파이는 같은 역할을 한다.
* 스파이는 수동으로 작성하는 반면, 목은 목 프레임워크의 도움을 받아 생성된다.

### 더미
* 더미는 null 값이나 가짜 문자열과가 같이 단순하고 하드코딩된 값이다.
* SUT의 메서드 시그니처를 만족시키기 위해 사용하고 최종 결과를 만드는 데 영향을 주지 않는다.

### 스텁
* 시나리오마다 다른 값을 반환하게끔 구성할 수 있도록 필요한 것을 다 갖춘 완전한 의존성이다.

### 페이크
* 대다수의 목적에 부합하는 스텁과 같다.
* 차이점은 생성에 있다. 페이크는 보통 아직 존재하지 않는 의존성을 대체하고자 구현한다.

### 목과 스텁
* 목은 SUT와 관련 의존성 간의 상호 작용을 모방하고 검사한다.
* 스텁은 모방만 한다.

### 스텁으로 상호 작용을 검증하지 말라
* 목은 SUT에서 관련 의존성으로 나가는 상호 작용을 모방하고 검사하는 반면, 스텁은 내부로 들어오는 상호 작용만 모방하고 검사하지 않는다.
  * 이 두 가지의 차이는 스텁과의 상호 작용을 검증하지 말라는 지침에서 비롯된다.
  * SUT에서 스텁으로의 호출은 SUT가 생성하는 최종 결과가 아니다. 최종 결과를 산출하기 위한 수단일 뿐이다.
* 스텁과의 상호 작용을 검증하는 것은 취약한 테스트를 야기하는 일반적인 안티 패턴이다.
* 최종 결과가 아닌 사항을 검증하는 관행을 과잉 명세(overspecification)라고 부른다.
  * 과잉 명세는 상호 작용을 검사할 때 가장 흔하게 발생한다.

### 목과 스텁, 명령과 조회의 관계
* 목과 스텁의 개념은 명령 조회 분리(CQS, Command Query Separation) 원칙과 관련이 있다.
* 명령은 부작용을 일으키고 어떤 값도 반환하지 않는 메서드다.
* 조회는 부작용이 없고 값을 반환한다.
* 물론 항상 CQS 원칙을 따를 수 있는 것은 아니다. 부작용을 초래하고 값을 반환하는 것이 적절한 메서드는 있기 마련이다.
  * 예를 들어 stack.pop()이 있다. 그래도 가능한 한 CQS 원칙을 따르는 것이 좋다.
* 명령을 대체하는 테스트 대역은 목이다.
* 조회를 대체하는 테스트 대역은 스텁이다.

### 식별할 수 있는 동작은 공개 API와 다르다
* 모든 코드는 2차원 코드로 분류할 수 있다.
  * 공개 API 또는 비공개 API
  * 식별할 수 있는 동작 또는 구현 세부 사항
* 각 차원의 범주는 겹치지 않는다.
  * 메서드는 공개 API와 비공개 API 둘 다에 속할 수 없다.
  * 코드는 내부 구현 세부 사항이거나 시스템의 식별할 수 있는 동작이지만 둘 다는 아니다.
* 코드가 시스템의 식별할 수 있는 동작이려면 다음 중 하나를 해야 한다.
  * 클라이언트가 목표를 달성하는 데 도움이 되는 연산을 노출하라. 연산은 계산을 수행하거나 부작용을 초래하거나 둘 다 하는 메서드다.
  * 클아이언트가 목표를 달성하는 데 도움이 되는 상태를 노출하라. 상태는 시스템의 현재 상태다.
  * 구현의 세부 사항은 위 두 가지 중 아무것도 하지 않는다.
* 이상적으로 시스템의 공개 API는 식별할 수 있는 동작과 일치해야 하며, 모든 구현 세부 사항은 클라이언트 눈에 보이지 않아야 한다.

### 클래스가 세부 구현 세항을 유출하는지 판단하는 데 도움이 되는 유용한 규칙
* 단일한 목표를 달성하고자 클래스에서 호출해야 하는 연산의 수가 1보다 크면 해당 클래스에서 구현 세부 사항을 유출할 가능성이 있다.
* 이상적으로는 단일 연산으로 개별 목표를 달성해야 한다.
  * 물론 예외 상황도 있다.
* 연산과 상태는 최소한으로 노출해야 한다.

### 육각형 아키텍처 정의
* 전형적인 애플리케이션은 도메인과 애플리케이션 서비스라는 두 계층으로 구성된다.
* 육각형 아키텍처는 세 가지 중요한 지침을 강조한다.
  * 도메인 계층과 애플리케이션 서비스 계층 간의 관심사 분리
  * 애플리케이션 내부 통신
  * 이플리케이션 간의 통신
* 애플리케이션의 각 계층은 식별할 수 있는 동작을 나타내며 해당 구현 세부 사항을 포함하고 있다.
* 애플리케이션 서비스를 다루는 테스트는 해당 서비스가 외부 클라이언트에게 중요하고 큰 목표를 어떻게 이루는지 확인한다.
* 도메인 클래스 테스트는 큰 목표의 하위 목표를 검증한다.

### 시스템 내부 통신과 세스템 간 통신
* 시스템 내부 통신은 애플리케이션 클래스 간의 통신이다.
* 시스템 간 통신은 애플리케이션이 다른 애플리케이션 간의 통신이다.
* 시스템 내부 통신은 구현 세부 사항이고, 시스템 간 통신은 그렇지 않다.
  * 연산을 수행하기 위한 도메인 클래스 간의 협력은 식별할 수 있는 동작이 아니므로 시스템 내부 통신은 구현 세부 사항에 해당한다.
    * 이러한 협력은 클라이언트의 목표와 직접적인 관계가 없으므로 결합되면 테스트가 취약해진다.
  * 시스템 외부 환경과 통신하는 방식은 전체적으로 해당 시스템의 식별할 수 있는 동작을 나타낸다. 이는 애플리케이션에 항상 있어야 하는 계약이다.
* 목을 사용하면 시스템과 외부 애플리케이션 간의 통신 패턴을 확인할 때 좋다.
* 반대로 시스템 내 클래스 간의 통신을 검증하는 데 사용하면 테스트가 구현 세부 사항과 결합되며, 리팩터링 내성 지표가 미흡해진다.

### 단위 테스트의 고전파와 런던파 재고
* 런던파는 불변 의존성을 제외한 모든 의존성에 목 사용을 권장하며 시스템 내 통신과 시스템 간 통신을 구분하지 않는다.
  * 그 결과로, 테스트는 애플리케이션과 외부 시스템 간의 통신을 확인하는 것처럼 클래스 간 통신도 확인한다.
* 런던파를 따라 목을 무분별하게 사용하면 종종 구현 세부 사항에 결합돼 테스트에 리팩터링 내성이 없게 된다.
* 고전파는 테스트 간에 공유하는 의존성만 교체하므로 이 문제에 대해 훨씬 유리하다.

### 모든 프로세스 외부 의존성을 목으로 해야 하는 것은 아니다.
* 프로세스 외부 의존성이 애플리케이션을 통해서만 접근할 수 있으면, 이러한 의존성과의 통신은 시스템에서 식별할 수 있는 동작이 아니다.
* 외부에서 관찰할 수 없는 프로세스 외부 의존성은 애플리케이션의 일부로 작용한다.
  * 애플리케이션을 통해서만 접근할 수 있는 외부 시스템과의 상호 작용의 부작용을 외부에서는 확인할 수 없기 때문이다.
* 목은 애플리케이션의 경계를 넘나드는 상호 작용을 검증할 때와 이러한 상호 작용의 부작용이 외부 환경에서 보일 때만 동작과 관련이 있다.
