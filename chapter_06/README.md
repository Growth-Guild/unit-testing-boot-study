# Chapter 06. 단위 테스트 스타일
- - -

## 단위 테스트의 세 가지 스타일
* 출력 기반 테스트
* 상태 기반 테스트
* 통신 기반 테스트

### 출력 기반 테스트
* 테스트 대상 시스템에 입력을 넣고 생성되는 출력을 점검하는 방식이다.
* 전역 상태나 내부 상태를 변경하지 않는 코드에만 적용되므로 반환 값만 검증하면 된다.
* 출력 기반 단위 테스트 스타일은 함수형이라고도 한다.
  * 부작용 없는 코드 선호를 강조하는 방식인 함수형 프로그래밍에 뿌리를 두고 있다.

### 상태 기반 스타일 정의
* 상태 기반 스타일은 작업이 완료된 후 시스템 상태를 확인하는 것이앋.
* 상태라는 용어는 SUT나 협력자 중 하나, 또는 데이터베이스나 파일 시스템 등과 같은 프로세스 외부 의존성의 상태 등을 의미할 수 있다.

### 통신 기반 스타일 정의
* 목을 사용해 테스트 대상 시스템과 협력자 간의 통신을 검증한다.

## 단위 테스트 스타일 비교

### 회귀 방지와 피드백 속도 지표로 스타일 비교
* 회귀 방지 지표는 특정 스타일에 따라 달라지지 않는다. 회귀 방지 지표는 다음 세 가지 특성으로 결정된다.
  * 테스트 중에 실행되는 코드의 양
  * 코드 복잡도
  * 도메인 유의성
* 보통 실행하는 코드가 많든 적든 원하는 대로 테스트를 작성할 수 있다. 어떤 스타일도 이 부분에서 도움이 되지 않는다. (코드 복잡도와 도메인 유의성도 마찬가지)
* 통신 기반 스타일에는 예외가 하나 있는데, 남용하면 작은 코드 조각을 검증하고 다른 것은 모두 목을 사용하는 등 피상적인 테스트가 될 수 있다. 이는 통신 기반 테스트의 결정적인 특징이 아니라 기술을 남용하는 극단적인 사례다.
* 테스트 스타일과 테스트 피드백 속도 사이에는 상관관계가 거의 없다.

### 리팩터링 내성 지표로 스타일 비교하기
* 출력 기반 테스트는 테스트가 테스트 대상 메서드에만 결합되므로 거짓 양성 방지가 가장 우수하다.
  * 테스트가 구현 세부 사항에 결합하는 경우는 테스트 대상 메서드가 구현 세부 사항일 때뿐이다.
* 상태 기반 테스트는 일반적으로 거짓 양성이 되기 쉽다.
* 통신 기반 테스트가 허위 경보에 가장 취약하다.
  * 테스트 대역으로 상호 작용을 확인하는 테스트는 대부분 깨지기 쉽기 때문이다.
    * 이는 스텁과 상호 작용하는 경우다. 이런 스텁과 상호 작용을 확인해서는 안 된다.
    * 애플리케이션 경계를 넘는 상호 작용을 확인하고 해당 상호 작용의 부작용이 외부 환경에 보이는 경우에만 목이 괜찮다.

### 유지 보수성 지표로 스타일 비교하기
* 유지 보수성 지표는 두 가지 특성으로 정의한다.
  * 테스트를 이해하기 얼마나 어려운가? (테스트 크기에 대한 함수)
  * 테스트를 실행하기 얼마나 어려운가? (테스트에 직접적으로 관련 있는 프로세스 외부 의존성 개수에 대한 함수)
* 출력 기반 테스트의 기반 코드는 전역 상태나 내부 상태를 변경할 리 없으므로, 프로세스 외부 의존성을 다루지 않는다.
* 상태 기반 테스트는 일반적으로 출력 기반 테스트보다 유지 보수가 쉽지 않다.
  * 상태 검증은 종종 출력 검증보다 더 많은 공간을 차지하기 때문이다.
  * 대부분 코드를 숨기고 테스트를 단축하는 헬퍼 메서드로 문제를 완화할 수 있지만, 이러한 메서드를 작성하고 유지하는 데 상당한 노력이 필요하다.
  * 상태 기반 테스트를 단축하는 또 다른 방법으로, 검증 대상 클래스의 동등 멤버를 정의할 수 있다.
    * 하지만 이는 본질적으로 클래스가 값에 해당하고 값 객체로 변환할 수 있을 떄만 효과적이다.
    * 그렇지 않으면 코드 오염으로 이어진다.

### 함수형 아키텍처
* 함수형 프로그래밍의 목표는 부작용을 완전히 제거하는 것이 아니라 비즈니스 로직을 처리하는 코드와 부작용을 일으키는 코드를 분리하는 것이다.
* 부작용을 비즈니스 연산 끝으로 몰아서 비즈니스 로직을 부작용과 분리한다.
* 다음 두 가지 코드 유형을 구분해서 비즈니스 로직과 부작용을 분리할 수 있다.
  * 결정을 내리는 코드 - 이 코드는 부작용이 필요 없기 때문에 수학적 함수를 사용해 작성할 수 있다.
  * 해당 결정에 따라 작용하는 코드 - 이 코드는 수학적 함수에 의해 이뤄진 모든 결정을 데이터베이스의 변경이나 메시지 버스로 전송된 메시지와 같이 가시적인 부분으로 변환한다.
* 결정을 내리는 코드는 함수형 코어라고도 하고, 결정에 따라 작용하는 코드는 가변 셸이라고도 한다.
* 함수형 코어와 가변 셸 계층을 잘 분리하기 하려면, 가변 셸이 의사 결정을 추가하지 않게끔 결정을 나타내는 클래스에 정보가 충분히 있는지 확인해야 한다.
  * 즉, 가변 셸은 가능한 한 아무 말도 하지 않아야 한다.
  * 목표는 출력 기반 테스트로 함수형 코어를 두루 다루고 가변 셸을 훨씬 더 적은 수의 통합 테스트에 맡기는 것이다.

### 함수형 아키텍처와 육각형 아키텍처 비교
* 둘의 점은 부작요엥 대한 처리에 있다.
* 함수형 아키텍처는 모든 부작용을 불변 코어에서 비즈니스 연산 가장자리로 밀어낸다.
  * 이 가장자리는 가변 셸이 처리한다.
* 육각형 아키텍처는 도메인 계층에 제한하는 한, 도메인 계층으로 인한 부작용도 문제없다.
  * 육각형 아키텍처의 모든 수정 사항은 도메인 계층 내에 있어야 하며, 계층의 경계를 넘어서는 안 된다.
* 함수형 아키텍처는 육각형 아키텍처의 하위 집합이다.
* 함수형 아키텍처와 전통적인 아키텍처 사이의 선택은 성능과 코드 유지 보수성 간의 절충이다.
  * 성능 영향이 적은 일부 시스템에서는 함수형 아키텍처를 통해 유지 보수성을 향상시키는 편이 낫다.
* 함수형 방식에서 순수성에 많은 비용이 든다면 순수성을 따르지 않는 것이 좋다.
* 대부분의 프로젝트에서는 모든 도메인 모델을 불변으로 할 수 없기 때문에 출력 기반 테스트에만 의존하기는 어렵다.
