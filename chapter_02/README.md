# Chapter 02. 단위 테스트란 무엇인가
- - -

## 단위 테스트의 정의
* 작은 코드 조각(단위라고도 함)을 검증하고,
* 빠르게 수행하고,
* 격리된 방식으로 처리하는 자동화된 테스트다.
* 여기서 격리 문제는 단위 테스트의 고전파와 런던파를 구분할 수 있게 해주는 근원적 차이에 속한다.

### 격리 문제에 대한 런던파의 접근
* 런던파에서는 테스트 대상 시스템을 협력자에게서 격리하는 것을 일컫는다.
  * 즉, 하나의 클래스가 다른 클래스 또는 여러 클래스에 의존하면 이 모든 의존성을 테스트 대역으로 대체해야 한다.
* 이 방법의 장점은 테스트가 실패하면 코드베이스의 어느 부분이 고장 났는지 확실히 알 수 있다는 점이다.
  * 클래스의 모든 의존성은 테스트 대역으로 대체됐기 때문에 의심할 여지가 없기 때문이다.
* 또 다른 장점은 객체 그래프를 분할할 수 있다는 점이다.
  * 테스트 대상이 의존하는 객체가 상당히 복잡한 객체 그래프를 가질 수 있는데, 테스트 대역을 통해 그래프를 효과적으로 분해하여 단위 테스트에서 준비를 크게 줄일 수 있다.
* 한 번에 한 클래스만 테스트하라는 지침을 도입하면 전체 단위 테스트 스위트를 간단한 구조로 할 수 있다.
* 테스트 대역은 실행과 관련 없이 모든 종류의 가짜 의존성을 설명하는 포괄적인 용어이며, 목은 그러한 의존성의 한 종류일 뿐이다.
* 목은 상태를 검증하며, 테스트 대상과 의존하는 대상 간의 상호 작용을 검사한다.

### 격리 문제에 대한 고전파의 접근
* 고전적인 방법에서 코드를 꼭 격리하는 방식으로 테스트해야 하는 것은 아니다.
  * 대신 단위 테스트는 서로 격리해서 실행해야 한다. (테스트를 어떤 순서로든 가장 적합한 방식으로 실행할 수 있으며 서로의 결과에 영향을 미치지 않도록 해야한다.)
* 공유 의존성
  * 테스트 간에 공유되고 서로의 결과에 영향을 미칠 수 있는 수단을 제공하는 의존성이다.
  * 대표적으로 정적 가변 필드가 있다.
* 비공개 의존성
  * 공유하지 않는 의존성이다.
* 프로세스 외부 의존성
  * 애플리케이션 실행 프로세스 외부에서 실행되는 의존성이며, 아직 메모리에 없는 데이터에 대한 프록시다.
  * 프로세스 외부 의존성은 대부분 공유 의존성에 해당하지만 모두 그런 것은 아니다. (데이터베이스는 프로세스 외부이면서 공유 의존성이지만, 테스트 실행 전에 도커 컨테이너로 데이터베이스를 시작하면 테스트가 더 이상 동일한 인스턴스로 작동하지 않기 때문에 공유하지 않는 의존성이 된다.)
* 공유 의존성을 대체하는 이유 중 한 가지는 테스트 실행 속도를 높이는데 있다.
  * 공유 의존성은 거의 항상 실행 프로세스 외부에 있는 데 반해, 비공개 의존성은 보통 그 경계를 넘지 않기 때문이다.
* 격리에 대한 다른 견해는 또한 단위를 구성하는 것에 대한 다른 견해로 이어진다.
  * 단위가 반드시 클래스에 국한될 필요는 없으며, 공유 의존성이 없는 한 여러 클래스를 묶어서 단위 테스트할 수도 있다.

### 단위 테스트의 런던파와 고전파
* 런던파와 고전파로 나눠진 원이는 격리 특성에 있다.
* 런던파는 테스트 대상 시스템에서 협력자를 격리하는 것으로 보는 반면, 고전파는 단위 테스트끼리 격리하는 것으로 본다.
* 런던파와 고전 파는 세 가지 주요 주제에 대해 의견 차이가 있다.
  * 격리 요구 사항
  * 테스트 대상 코드 조각의 구성 요소
  * 의존성 처리
* 격리 주체
  * 런던파 - 단위
  * 고전파 - 단위 테스트
* 단위의 크기
  * 런던파 - 단일 클래스
  * 고전파 - 단일 클래스 또는 클래스 세트
* 테스트 대역 사용 대상
  * 런던파 - 불변 의존성 외 모든 의존성
  * 고전파 - 공유 의존성

#### 의존성
* 의존성은 공유되거나 비공개일 수 있다.
* 비공개 의존성은 변경가 가능하거나 불변일 수 있다.
* 불변일 경우 값 객체라고 부른다.
> 예를 들어 데이터베이스는 공유 의존성이며, 내부 상태(테스트 대역으로 대체되지 않은)는 모든 자동화된 테스트에서 공유한다.
* 여기서 공유 의존성, 비공개 의존성을 나누는 기준은 단위 테스트 간에 서로 공개되어 영향을 미칠 수 있는 의존성인지로 구분한다.
* 모든 공유 의존성은 변경 가능하지만, 변경 가능한 의존성을 공유하려면 여러 테스트에서 재사용돼야 한다.
* 고전파에서는 공유 의존성을 테스트 대역으로 교체한다.
* 런던파에서는 변경 가능한 한 비공개 의존성도 테스트 대역으로 교체할 수 있다.
* 협력자는 공유하거나 변경 가능한 의존성이다.
* 모든 프로세스 외부 의존성이 공유 의존성의 범주에 속하는 것은 아니다.
  * 공유 의존성은 거의 항상 프로세스 외부에 있지만, 그 반대는 그렇지 않다.

## 고전파와 런던파 비교
* 고전파와 런던파 간의 주요 차이는 단위 테스트의 정의에서 격리 문제를 어떻게 다루는지에 있다.
* 런던파의 장점
  * 입자성이 좋다. 테스트가 세밀해서 한 번에 한 클래스만 확인한다.
  * 서로 연결된 클래스의 그래프가 커져도 테스트하기 쉽다.
  * 테스트가 실패하면 어떤 기능이 실패했는지 확실히 알 수 있다.

### 한 번에 한 클래스만 테스트하기
* 런던파는 클래스를 단위로 간주한다.
  * 클래스를 모든 코드베이스의 기초에 위치한 원자 빌딩 블록으로 간주한다.
```text
테스트는 코드의 단위를 검증해서는 안된다. 
동작의 단위, 즉 문제 영역에 의미가 있는 것, 이상적으로는 비즈니스 담당자가 유용하다고 인식할 수 있는 것을 검증해야 한다.
동작 단위를 구현하는 데 클래스가 얼마나 필요한지는 상관없다.
단위는 여러 클래스에 걸쳐 있거나 한 클래스에만 있을 수 있고, 심지어 아주 작은 메서드가 될 수도 있다.
```
* 따라서 좋은 코드 입자성을 목표로 하는 것은 도움이 되지 않는다.
* 테스트가 단일 동작 단위를 검증하는 한 좋은 테스트다.

### 상호 연결된 클래스의 큰 그래프를 단위 테스트하기
* 실제 협력자를 대신해 목을 사용하면 클래스를 쉽게 테스트할 수 있다.
* 고전파를 따라 테스트 대상 시스템을 설정하려면 전체 객체 그래프를 다시 생성해야 하는데, 이는 작업이 많을 수 있다.
  * 하지만 상호 연결된 클래스의 크고 복잡한 그래프를 테스트할 방법을 찾는 대신, 먼저 이러한 클래스 그래프를 갖지 않는데 집중해야 한다.
  * 대개 클래스 그래프가 커진 것은 코드 설계 문제의 결과다.

### 버그 위치 정확히 찾아내기
* 런던 스타일 테스트가 있는 시스템에 버그가 생기면, 보통 SUT에 버그가 포함된 테스트만 실패한다.
* 고전적인 방식에서는 오작동하는 클래스를 참조하는 클라이언트를 대사으로 하는 테스트도 실패할 수 있다.
  * 즉 하나의 버그가 전체 시스템에 걸쳐 테스트 실패를 야기하는 파급 효과를 초래하며, 이는 문제의 원인을 찾기 더 어렵게 만든다.
  * 하지만 테스트를 정기적으로 실행하면 버그의 원인을 알아낼 수 있다.
  * 또한 실패한 테스트를 모두 볼 필요는 없다. 하나를 고치면 다른 것들도 자동으로 고쳐지기 때문이다.

### 고전파와 런던파 사이의 다른 차이점
* 런던 스타일의 단위 테스트는 하향식 TDD로 이어지며, 전체 시스템에 대한 기대치를 설정하는 상위 레벨 테스트부터 시작한다.
  * 목을 사용해 예상 결과를 당성하고자 시스템이 통신해야 하는 협력자를 지정한다.
  * 그런 다음 모든 클래스를 구현할 때까지 클래스 그래프를 다져나간다.
  * 목은 한 번에 한 클래스에 집중할 수 있기 때문에 이 설계 프로세스를 가능하게 한다.
* 고전파는 테스트에서 실제 객체를 다뤄야 하기 때문에 지침을 똑같이 두지 않고, 일반적으로 상향식으로 한다.
  * 도메인 모델을 시작으로 최종 사용자가 소프트웨어를 사용할 수 있을 때까지 계층을 그 위에 더 둔다.

### 통합 테스트와 엔트 투 엔드 테스트
* 통합 테스트는 단위 테스트 기준 중 하나 이상을 충족하지 못하는 테스트다.
* e2e 테스트는 통합 테스트의 일부이며, 최종 사용자의 관점에서 시스템을 검증한다.
* e2e 테스트는 애플리케이션과 함께 작동하는 프로세스 외부 의존성의 전부 또는 대부분에 직접 접근한다.
